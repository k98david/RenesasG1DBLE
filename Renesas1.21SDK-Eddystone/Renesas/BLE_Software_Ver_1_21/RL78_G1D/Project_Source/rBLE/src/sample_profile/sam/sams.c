/*******************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only
 * intended for use with Renesas products. No other uses are authorized. This
 * software is owned by Renesas Electronics Corporation and is protected under
 * all applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
 * LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
 * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
 * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
 * ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
 * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software
 * and to discontinue the availability of this software. By using this software,
 * you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 * (C) 2012-2017 Renesas Electronics Corporation All rights reserved.
 ******************************************************************************/

/******************************************************************************
 * File Name  : sams.c
 * Version    : 1.0
 * Description: sample custom profile server role code file
 *
 * Copyright(C) 2013-2017 Renesas Electronics Corporation
 *
 * This file is generated by Bluetooth Developer Studio plugin.
 *     BDS Version    : 1.1.3139.0
 *     Script Version : 2.0.1
 *
 ******************************************************************************/

/*******************************************************************************
 * Include Files
 ******************************************************************************/
#include "sams.h"
#include "rble_api.h"
#include "db_handle.h"

/*******************************************************************************
 * Enumeration Definitions
 ******************************************************************************/
typedef enum {
    NEW_PROFILE_SERVER_STATE_IDLE,
    NEW_PROFILE_SERVER_STATE_INIT,
    NEW_PROFILE_SERVER_STATE_CONNECTED,
} NEW_PROFILE_SERVER_STATE;

typedef enum {
    NEW_PROFILE_SERVER_INIT_STATE_END,
} NEW_PROFILE_SERVER_INIT_STATE;

/*******************************************************************************
 * Global Variables
 ******************************************************************************/
static struct {
    uint16_t conhdl;
    NEW_PROFILE_SERVER_STATE state;
    NEW_PROFILE_SERVER_INIT_STATE init_state;
    NEW_PROFILE_SERVER_PARAM param;
    NEW_PROFILE_SERVER_EVENT_HANDLER callback;
    RBLE_STATUS status;
    /* for set_data & write_cmd handling */
    uint16_t hdl;
    uint16_t len;
    uint8_t  value[20];
    uint16_t send_ntf_ind;
    BOOL     write_cmd_ind;
} info;

#define QUEUE_MAX 3
static SET_DATA_INFO queue[QUEUE_MAX];

static uint8_t queue_ct = 0;   /* Number of queueing [0 - (QUEUE_MAX -1)] */
static uint8_t queue_w_p = 0;  /* Queueing write pointer */ 
static uint8_t queue_r_p = 0;  /* Queueing read pointer */

static BOOL now_set_data = FALSE;


/*******************************************************************************
 * Function Declarations
 ******************************************************************************/
static void new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_TYPE type);

static void new_profile_server_set_init_data(void);
void new_profile_server_set_data(SET_DATA_INFO *sd_info);
static void new_profile_server_write_resp(BOOL flg);
static void new_profile_server_set_data_cmp_handler(RBLE_GATT_EVENT *event);
static void new_profile_server_write_cmd_ind_handler(RBLE_GATT_EVENT *event);
static void new_profile_server_gatt_callback(RBLE_GATT_EVENT *event);
static BOOL new_profile_server_set_data_queueing(SET_DATA_INFO *data);
static BOOL new_profile_server_set_data_queue_read(SET_DATA_INFO *data);

/*******************************************************************************
 * Function Definitions (Internal)
 ******************************************************************************/
static void new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_TYPE type)
{
    NEW_PROFILE_SERVER_EVENT event;

    event.type   = type;
    event.conhdl = info.conhdl;

    switch (type) {
    case NEW_PROFILE_SERVER_EVENT_ENABLE_COMP:
        event.status = info.status;
        break;

    case NEW_PROFILE_SERVER_EVENT_DISABLE_COMP:
        event.status = info.status;
        break;
        
    case NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP:
        event.status = info.status;
        event.param.set_value_comp_evt.char_hdl = info.hdl;
        break;
        
    case NEW_PROFILE_SERVER_EVENT_CHAR_WRITE_RESP:
        event.status = info.status;
        event.param.char_write_resp_evt.char_hdl = info.hdl;
        switch( info.hdl )
        {
			case NEW_PROFILE_HDL_BS_N_UID_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_N_uid_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_N_uid_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_uid_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_url_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
			case NEW_PROFILE_HDL_BS_L_UID_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_L_uid_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_L_uid_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_uid_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_url_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
			case NEW_PROFILE_HDL_BS_R_UID_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_R_uid_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_R_uid_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_uid_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_url_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
				
				
			case NEW_PROFILE_HDL_BS_N_URL_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_N_url_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_N_url_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_url_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_uid_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
				
			case NEW_PROFILE_HDL_BS_L_URL_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_L_url_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_L_url_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_url_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_uid_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
				
			case NEW_PROFILE_HDL_BS_R_URL_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_R_url_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_R_url_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_url_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_uid_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				break;
				
				
				
			case NEW_PROFILE_HDL_BS_Set1_VAL:
			/*
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_status_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_status_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_status_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_uid_char_val_len=0;
				event.param.char_write_resp_evt.bs_cmd_char_val_len=0;
				event.param.char_write_resp_evt.bs_url_char_val_len=0;
				*/
				break;
				
			case NEW_PROFILE_HDL_BS_CMD_VAL:
				event.param.char_write_resp_evt.char_write_resp_evt_val.bs_cmd_char_val[0] = info.value[0];
				
				memcpy(event.param.char_write_resp_evt.char_write_resp_evt_val.bs_cmd_char_val, &info.value[0], info.len);
    				event.param.char_write_resp_evt.bs_cmd_char_val_len= info.len;
				event.param.char_write_resp_evt.bs_uid_char_val_len=0;
				event.param.char_write_resp_evt.bs_status_char_val_len=0;
				event.param.char_write_resp_evt.bs_url_char_val_len=0;
				break;
            default:
                /* Characteristic hdl not found */
                break;
        }
        break;
        
    default:
        /* Unsupported NEW_PROFILE_SERVER event */
        break;
    }

    info.callback(&event);
}


static void new_profile_server_set_init_data(void)
{
    switch (info.init_state) {

    case NEW_PROFILE_SERVER_INIT_STATE_END:
        info.state  = NEW_PROFILE_SERVER_STATE_CONNECTED;
        info.status = RBLE_OK;
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_ENABLE_COMP);
        now_set_data = FALSE;
        break;

    default:
        /* Unknown NEW_PROFILE_SERVER init state */
        break;
    }
}

/* ##### GATT Functions ##### */
void new_profile_server_set_data(SET_DATA_INFO *sd_info)
{
    RBLE_GATT_SET_DATA data;

    info.hdl = sd_info->hdl;
    info.len = sd_info->len;
    memcpy(info.value, sd_info->value, sd_info->len);
    info.send_ntf_ind = sd_info->send_ntf_ind;
    info.write_cmd_ind = sd_info->write_cmd_ind;

    data.val_hdl = sd_info->hdl;
    data.val_len = sd_info->len;
    memcpy(data.value, sd_info->value, sd_info->len);

    now_set_data = TRUE;
    (void)RBLE_GATT_Set_Data(&data);
}

static void new_profile_server_write_resp(BOOL flg)
{
    RBLE_GATT_WRITE_RESP resp;

    if (TRUE == info.write_cmd_ind) {
        resp.conhdl   = info.conhdl;
        resp.att_hdl  = info.hdl;
        if( flg == TRUE )
        {
            resp.att_code = info.status;
        }
        else
        {
            resp.att_code = RBLE_ATT_ERR_QUEUE_FULL;
        }
        (void)RBLE_GATT_Write_Response(&resp);
    }
}

/* ##### GATT Event Handlers ##### */
static void new_profile_server_set_data_cmp_handler(RBLE_GATT_EVENT *event)
{
    struct RBLE_GATT_Set_Data_Complete_t *result =
        (struct RBLE_GATT_Set_Data_Complete_t *)&event->param.set_data_cmp;

    info.status = result->status;

    if (NEW_PROFILE_SERVER_STATE_INIT == info.state) {
        now_set_data = FALSE;
        new_profile_server_set_init_data();
        return;
    }

    switch(info.hdl)
    {
    case NEW_PROFILE_HDL_BS_N_UID_VAL:
    case NEW_PROFILE_HDL_BS_L_UID_VAL:
    case NEW_PROFILE_HDL_BS_R_UID_VAL:
        if( info.write_cmd_ind == TRUE )
        {
            new_profile_server_write_resp(TRUE);
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_CHAR_WRITE_RESP);
        }
        else
        {
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        }
        break;
        
    case NEW_PROFILE_HDL_BS_N_URL_VAL:
    case NEW_PROFILE_HDL_BS_L_URL_VAL:
    case NEW_PROFILE_HDL_BS_R_URL_VAL:
        if( info.write_cmd_ind == TRUE )
        {
            new_profile_server_write_resp(TRUE);
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_CHAR_WRITE_RESP);
        }
        else
        {
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        }
        break;
	
	
	
        
    case NEW_PROFILE_HDL_BS_Set1_VAL:
    case NEW_PROFILE_HDL_BS_Set2_VAL:
    case NEW_PROFILE_HDL_BS_Set3_VAL:
    case NEW_PROFILE_HDL_BS_Set4_VAL:
        if( info.write_cmd_ind == TRUE )
        {
            new_profile_server_write_resp(TRUE);
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_CHAR_WRITE_RESP);
        }
        else
        {
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        }
        break;
	
    case NEW_PROFILE_HDL_BS_CMD_VAL:
        if( info.write_cmd_ind == TRUE )
        {
            new_profile_server_write_resp(TRUE);
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_CHAR_WRITE_RESP);
        }
        else
        {
            new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        }
        break;
        
    case NEW_PROFILE_HDL_DI_MANUFACTURER_NAME_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_MODEL_NUMBER_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_SERIAL_NUMBER_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_HARDWARE_REVISION_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_FIRMWARE_REVISION_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_SOFTWARE_REVISION_STRING_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_SYSTEM_ID_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    case NEW_PROFILE_HDL_DI_PNP_ID_VAL:
        new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_SET_VALUE_COMP);
        break;
        
    default:
        /* Unsupported hdl */
        break;
    }

    /* Next Set_Data check */
    if( queue_ct > 0 )
    {
        SET_DATA_INFO data;
        
        new_profile_server_set_data_queue_read( &data );
        new_profile_server_set_data( &data );
    }
    else
    {
        now_set_data = FALSE;
    }
}

static void new_profile_server_write_cmd_ind_handler(RBLE_GATT_EVENT *event)
{
    struct RBLE_GATT_Write_Cmd_Ind_t *result =
        (struct RBLE_GATT_Write_Cmd_Ind_t *)&event->param.write_cmd_ind;
    SET_DATA_INFO data;

    data.hdl           = result->elmt;
    data.len           = result->size;
    data.write_cmd_ind = result->resp;
    data.send_ntf_ind  = NEW_PROFILE_SERVER_DESC_ALL_DISABLE;

    memset(data.value, 0, data.len);

    switch (result->elmt) {
    case NEW_PROFILE_HDL_BS_N_UID_VAL:
        memcpy( (data.value), (result->value), result->size);
        break;
        
    case NEW_PROFILE_HDL_BS_N_URL_VAL:
        memcpy( (data.value), (result->value), result->size);
        break;
        
    case NEW_PROFILE_HDL_BS_Set1_VAL:
        memcpy( (data.value), (result->value), result->size);
        break;
        
    case NEW_PROFILE_HDL_BS_CMD_VAL:
        memcpy( (data.value), (result->value), result->size);
        break;
	
    default:
        /* Unsupported hdl */
        break;
    }

    if( !(new_profile_server_set_data_queueing(&data)) )
    {
        RBLE_GATT_WRITE_RESP resp;

        if( data.write_cmd_ind == TRUE )
        {
            resp.conhdl   = result->conhdl;
            resp.att_hdl  = result->elmt;
            resp.att_code = RBLE_ATT_ERR_QUEUE_FULL;
            (void)RBLE_GATT_Write_Response(&resp);
        }
    }
}

static void new_profile_server_gatt_callback(RBLE_GATT_EVENT *event)
{
    switch (event->type) {
    case RBLE_GATT_EVENT_SET_DATA_CMP:
        new_profile_server_set_data_cmp_handler(event);
        break;

    case RBLE_GATT_EVENT_WRITE_CMD_IND:
        new_profile_server_write_cmd_ind_handler(event);
        break;

    default:
        /* Unsupported GATT event */
        break;
    }
}

static BOOL new_profile_server_set_data_queueing(SET_DATA_INFO *data)
{
    if( queue_ct >= QUEUE_MAX )
    {
        /* Queueing buffer full */
        return FALSE;
    }
    
    if( now_set_data == TRUE )
    {
        /* Set_Data is running -> Queueing */
        
        /* Queueing data count increment */
        queue_ct++;
        
        /* Queueing data set */
        queue[queue_w_p].hdl = data->hdl;
        queue[queue_w_p].len = data->len;
        memcpy(queue[queue_w_p].value, data->value, data->len);
        queue[queue_w_p].send_ntf_ind = data->send_ntf_ind;
        queue[queue_w_p].write_cmd_ind = data->write_cmd_ind;
        
        /* Queueing write pointer increment */
        queue_w_p++;
        if( queue_w_p >= QUEUE_MAX )
        {
            queue_w_p = 0;
        }
    }
    else
    {
        /* Set_Data is not running -> Set_Data execution */
        SET_DATA_INFO sd_info;
        
        sd_info.hdl = data->hdl;
        sd_info.len = data->len;
        memcpy(sd_info.value, data->value, data->len);
        sd_info.send_ntf_ind = data->send_ntf_ind;
        sd_info.write_cmd_ind = data->write_cmd_ind;

        new_profile_server_set_data( &sd_info );
    }
    
    return TRUE;
}

static BOOL new_profile_server_set_data_queue_read(SET_DATA_INFO *data)
{
    if( queue_ct == 0 )
    {
        /* Queueing buffer empty */
        return FALSE;
    }
    
    /* Queueing data count decrement */
    queue_ct--;
    
    /* Queueing data pop */
    data->hdl = queue[queue_r_p].hdl;
    data->len = queue[queue_r_p].len;
    memcpy(data->value, queue[queue_r_p].value, data->len);
    data->send_ntf_ind = queue[queue_r_p].send_ntf_ind;
    data->write_cmd_ind = queue[queue_r_p].write_cmd_ind;
    
    /* Queieing read pointer increment */
    queue_r_p++;
    if( queue_r_p >= QUEUE_MAX )
    {
        queue_r_p = 0;
    }

    return TRUE;
}


/*******************************************************************************
 * Function Definitions (API)
 ******************************************************************************/
RBLE_STATUS NEW_PROFILE_Server_Enable(uint16_t conhdl, uint8_t con_type,
                                 NEW_PROFILE_SERVER_PARAM *param, NEW_PROFILE_SERVER_EVENT_HANDLER callback)
{
    RBLE_STATUS status;

    if (!callback || !param) {
        return RBLE_PARAM_ERR;
    }

    if (NEW_PROFILE_SERVER_STATE_IDLE != info.state) {
        return RBLE_STATUS_ERROR;
    }

    status = RBLE_GATT_Enable(&new_profile_server_gatt_callback);
    if (RBLE_OK != status) {
        return RBLE_STATUS_ERROR;
    }

    memset(&info, 0, sizeof(info));

    info.conhdl     = conhdl;
    info.callback   = callback;
    info.state      = NEW_PROFILE_SERVER_STATE_INIT;
    info.init_state = NEW_PROFILE_SERVER_INIT_STATE_END;

    if (RBLE_PRF_CON_NORMAL == con_type) {
    }

    new_profile_server_set_init_data();

    return RBLE_OK;
}

RBLE_STATUS NEW_PROFILE_Server_Disable(uint16_t conhdl)
{
    if (info.conhdl != conhdl) {
        return RBLE_PARAM_ERR;
    }

    if (NEW_PROFILE_SERVER_STATE_CONNECTED != info.state) {
        return RBLE_STATUS_ERROR;
    }

    if( queue_ct > 0 )
    {
        return RBLE_BUSY;
    }

    info.state = NEW_PROFILE_SERVER_STATE_IDLE;

    info.status = RBLE_OK;
    new_profile_server_send_event(NEW_PROFILE_SERVER_EVENT_DISABLE_COMP);

    return RBLE_OK;
}

RBLE_STATUS NEW_PROFILE_Server_Set_Value(uint16_t char_hdl, uint8_t *char_val)
{
    uint16_t len = 0;
    SET_DATA_INFO data;

    if (NEW_PROFILE_SERVER_STATE_CONNECTED != info.state) {
        return RBLE_STATUS_ERROR;
    }

    if( NULL == char_val )
    {
        return RBLE_PARAM_ERR;
    }

    switch( char_hdl )
    {
    case NEW_PROFILE_HDL_BS_N_UID_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_L_UID_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_R_UID_VAL:
		len = Chr_len;
        break;
	
    case NEW_PROFILE_HDL_BS_N_URL_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_L_URL_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_R_URL_VAL:
		len = Chr_len;
        break;
	
    case NEW_PROFILE_HDL_BS_Set1_VAL:
		len = Chr_len;
        break;
	
    case NEW_PROFILE_HDL_BS_Set2_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_Set3_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_Set4_VAL:
		len = Chr_len;
        break;
    case NEW_PROFILE_HDL_BS_CMD_VAL:
		len = Chr_len;
        break; 
	
    case NEW_PROFILE_HDL_DI_MANUFACTURER_NAME_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_MODEL_NUMBER_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_SERIAL_NUMBER_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_HARDWARE_REVISION_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_FIRMWARE_REVISION_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_SOFTWARE_REVISION_STRING_VAL:
        len = 7;
        break;
        
    case NEW_PROFILE_HDL_DI_SYSTEM_ID_VAL:
        len = 8;
        break;
        
    case NEW_PROFILE_HDL_DI_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_VAL:
        len = 6;
        break;
        
    case NEW_PROFILE_HDL_DI_PNP_ID_VAL:
        len = 7;
        break;
        
    default:
        return RBLE_PARAM_ERR;
    }

    data.hdl = char_hdl;
    data.len = len;
    memcpy(data.value, char_val, data.len);
    data.send_ntf_ind = NEW_PROFILE_SERVER_DESC_ALL_DISABLE;
    data.write_cmd_ind = FALSE;
    if( FALSE == new_profile_server_set_data_queueing(&data) )
    {
        return RBLE_BUSY;
    }

    return RBLE_OK;
}
